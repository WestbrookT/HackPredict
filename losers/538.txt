My sister convinced me to run a half marathon with her later this year. She lives in Washington DC, so we can never run against one another. I wanted a better way to compete with her other than texting our times back and forth. Brian and I built Run With Me to do just that. Run With Me provides real time information during the race, and can drive us to run harder as if we were next to each other.
Nothing inspires a person more than a competition, and until now the only competition in running applications was data vs data.  You look up a run.  You do the run.  You check your standings.  No live feedback.  No real motivation to run faster.  You never run harder than when someone is there next to you.  Pushing you to the limit.  But what if your running partner isn’t in the same City or timezone?  Perhaps this distance keeps you running solo?  Run With Me makes sure that there is always someone right next to you.  With Run With Me you choose a time and a distance, and then challenge someone to a virtual race.  A GPS enabled running band synchronizes you and your partners distance as you both run.  In race audio notifications let you know if you are ahead, behind or finished.  Don’t always have a running partner?  Our ghost runner feature allows you to challenge a previous run performed by you or anyone in the Run With Me community.  Run like you should…Run With Me.
The system consists of: a UI written with React JS framework and Mongo DB for storage, an arduino platform with GPS and zigbee modules and python/django applications.  The ardunio platform is hardware that I had constructed for a previous project.  This includes all of the soldering and positions of the sensors on the board.  To use the application the user would run with the ardunio platform and the gps readings will be read every 4 seconds and then sent to a computer via zigbee.  Once received by the computer a python application hits a django rest service to load the readings into the database.  The React application maintains the user presentation of the race.  Positions will be periodically polled from the javascript application via the rest service to determine the progress of the race.  During the race audio updates will indicate to a user when passing or falling behind.  At the completion of the race the application resets and a new race can begin.
The first challenge was working with a bluetooth module.  The original plan for communication with the armband platform was to have it communicate over bluetooth to a background cell phone application that would load values into the database via the django rest service.  Despite my best efforts the bluetooth module would not work with the arduino uno platform due to a missing output pin on the bluetooth module.  Without the output pin debugging was not going to be possible while the bluetooth device was attached to the arduino, so we decided it would be best to reevaluate the approach.  I had some basic python code for Zigbee Digimesh, so instead of bluetooth to phone the armband platform sends data over zigbee to a computer.  This vastly reduced the portability of the proof of concept system.
Challenges with the javascript program were mostly related to quantity of work required to get the framework and race program running.  Most of the work itself was straight forward, but it was difficult to work long hours on little sleep to complete the project. We made design decisions early on in the project that left most of the major lifting to the javascript application. A more balanced devision of the functionality between the two applications would have made it easier to isolate issues.
Some of the design decisions that we made early on in the process led to an imbalance in the work.  By relying heavily on the javascript program to store information and execute the race itself Dan was saddled with a disproportionate amount of the work.  In the future it would be good to do a more thorough breakdown of the expected work to ensure that work can be split more easily. 
It is important to schedule deliberate moments to evaluate progress, and rearrange development resources.    
We would like to create our own arm band that allows us to add other sensors to provide runners with additional data (heart rate, breathing rate. sweat rate, etc), but we have to acknowledge that there are already many fitness bands out there.  Run With Me would benefit greatly if it could work at least in some capacity with popular fitness bands and trackers.
A future iteration of the arm band running platform that we design would have to be bluetooth enabled to allow the user to pair with a phone to upload the live data into the database.  Additional sensors would be modular so they can be added to the platform with minimal effort by the user.
The UI that we have created is merely the tip of the iceberg of functionality that can be provided given the data collected.  Beyond live in race statistics Run with Me would provide historical race data analysis, custom sound recording, and both android and IOS support.  The potential for custom race views, charts and statistics leaves the design of the final application decidedly open ended.